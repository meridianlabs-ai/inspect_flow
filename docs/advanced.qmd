---
title: "Advanced"
tbl-colwidths: [30,70]
---

### Metadata

Flow supports two types of metadata with distinct purposes: `metadata` and `flow_metadata`.

#### metadata (Inspect AI Metadata)

The `metadata` field in `FlowOptions` and `FlowTask` is passed directly to Inspect AI and stored in evaluation logs. Use this for tracking experiment information that should be accessible in Inspect AI's log viewer and analysis tools.

**Example:**

``` {.python filename="metadata.py"}
{{< include ../examples/metadata.py >}}
```

The metadata from `FlowOptions` is applied globally to all tasks in the evaluation run, while task-level metadata is specific to each task.

#### flow_metadata (Flow-Only Metadata)

The `flow_metadata` field is available on `FlowJob`, `FlowTask`, `FlowModel`, `FlowScorer`, `FlowSolver`, and `FlowAgent`. This metadata is **not passed to Inspect AI**â€”it exists only in the Flow configuration and is useful for configuration-time logic and organization.

**Use cases:**

-   Filtering or selecting configurations based on properties
-   Organizing complex configuration generation logic
-   Documenting configuration decisions
-   Annotating configs without polluting Inspect AI logs

**Example: Configuration-time filtering**

``` {.python filename="flow_metadata.py"}
{{< include ../examples/flow_metadata.py >}}
```

### Parameterized Jobs

#### Flow Args (`--arg`)

Pass custom variables to Python config files using `--arg` or the `INSPECT_FLOW_ARG` environment variable. 
Use this for dynamic configuration that isn't available via `--set`.
To access the args the last statement in the config file should be a function that returns a `FlowJob`.
This function will be called with any provided args:

```bash
flow run flow_args.py --arg task_min_priority=2
```

``` {.python filename="flow_args.py"}
{{< include ../examples/flow_args.py >}}
```

#### Template Substitution

Use `{field_name}` syntax to reference other FlowJob configuration values. Substitutions are applied after the config is loaded:

```python
FlowJob(
    log_dir="logs/my_eval",
    options=FlowOptions(bundle_dir="{log_dir}/bundle"),
    # Result: bundle_dir="logs/my_eval/bundle"
)
```

For nested fields, use bracket notation: `{options[eval_set_id]}` or `{flow_metadata[key]}`. Substitutions are resolved recursively until no more remain.

### Viewer Bundling

Viewer bundling works the same way as [`eval_set()`](https://inspect.aisi.org.uk/eval-sets.html) in Inspect AI and is configurable via `FlowOptions`. An additional feature allows you to print bundle URLs for users running evaluations.

Convert local bundle paths to public URLs for sharing evaluation results. The `bundle_url_map` in `FlowOptions` applies string replacements to `bundle_dir` to generate a shareable URL that's printed to stdout after the evaluation completes.

``` {.python filename="bundle_url_map.py"}
{{< include ../examples/bundle_url_map.py >}}
```

After running this prints: `Bundle URL: https://example.com/shared/bundles/my_eval`

Use this when storing bundles on servers with public HTTP access or cloud storage with URL mapping. Multiple mappings are applied in order.

Using Bundle URL maps makes sense along with the job [inheritance](inheritance.qmd) feature so you can configure the same bundle mapping for all configs in a repository.

### Configuration Scripts

When loading a configuration file, Flow expects the last expression to either be a `FlowJob` or a function that returns a `FlowJob`.
Other than this requirement, the configuration file may execute arbitrary code.
One example of functionality that can be implemented using this feature is validation code to enforce constraints.
Instead of repeating this validation code in every Flow configuration file, the code could be placed in a _flow.py file that is auto included.
In this section, first we provide a detailed example of a Flow include structure.
Then we provide example configuration scripts that can be used to enforce constraints.

#### Flow Includes Detailed Example

Flow files may be included in two ways:
- Files named `_flow.py` are automatically included from parent directories.
  - When using the CLI to load a file, only _flow.py files in the parent directories of the configuration file provided are automatically included.
  - When the API prepares a job that contains includes, only _flow.py files in the parent directories of the base_dir arg are automatically included.
- Other configuration files can be explicitly included using the `includes` field in the `FlowJob`.

Assume the following file structure:
~/_flow.py
~/a/_flow.py
~/a/b/1flow.py
~/a/b/2flow.py
~/a/b/my_config.py
~/a/c/_flow.py
~/a/c/2_1flow.py

And the following includes:
- 2flow.py includes 2_1flow.py
- my_config-py includes 1flow.py and 2flow.py

~/a/c/_flow.py will not be loaded.
Even though ~/a/c/2_1flow.py is loaded from the directory, Flow only automatically includes files in the same directory is my_config.py and its parents.

The config files will be loaded and applied in the following order:
1. my_config.py is loaded
1. 1flow.py is loaded (including config is my_config.py)
1. 1flow.py is applied to my_config.py to create an updated my_config
1. 2flow.py is loaded (including config is my_config.py)
1. 2_1flow.py is loaded (including configs are my_config.py and 2flow.py)
1. 2_1flow is appliec to 2flow.py to create an updated 2flow
1. The updated 2flow is applied to the updated my_config to create a new update to my_config
1. ~/a/_flow.py is loaded (including config is my_config.py)
1. ~/a/_flow.py is applied to the updated my_config to crate a new update to my_config
1. ~/_flow.py is loaded (including config is my_config.py)
1. ~/_flow.py is applied to the updated my_config to create a new update to my_config

When includes are applied any values in the including config overwrite the value in the included config.
In many cases this is the desired behavior, as the final config file can override values in the included files.
However, sometimes the included file may want to prevent a value from being overridden.

#### including_jobs

When loading a config file, the `included_jobs()` function can be used to access the including files.
`including_jobs()` returns a dictionary mapping file path to `FlowJob` for all the jobs in the include chain that have been loaded but not yet applied.
Often this will only be the single file (`my_config.py`) and most recently updated version of the `FlowJob`.
In the case of a longer include chain (an included file including another include file, as is the case when loading `2_1flow.py` in the above example) this will contain multiple items.

#### Prevent Runs with Uncommitted Changes

Place a `_flow.py` file at your repository root to validate that all configs are in clean git repositories. This validation runs automatically for all configs in subdirectories.

``` {.python filename="_flow.py"}
{{< include ../examples/dirty_git_check/_flow.py >}}
```

``` {.python filename="config.py"}
{{< include ../examples/dirty_git_check/including/config.py >}}
```

#### Lock Configuration Fields

A `_flow.py` file can prevent configs from overriding critical settings:

``` {.python filename="_flow.py"}
{{< include ../examples/lock/_flow.py >}}
```

``` {.python filename="config.py"}
{{< include ../examples/lock/including/config.py >}}
```

This pattern is useful for enforcing organizational standards (resource limits, safety constraints, etc.) across all evaluation configs in a repository.
Even though `including_jobs` does not include jobs that have either already been applied or not yet been loaded.

