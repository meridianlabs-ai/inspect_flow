---
title: "Matrixing"
tbl-colwidths: [30,70]
---

Matrixing lets you systematically explore evaluation configurations by generating Cartesian products of parameters. Instead of manually writing every combination, Flow provides `*_matrix()` and `*_with()` functions to declaratively generate evaluation grids.

## Matrix Functions

Matrix functions generate all combinations of their parameters using Cartesian products.

### tasks_matrix()

Generate task configurations by combining tasks with models, configs, solvers, and arguments:

``` {.python filename="tasks_matrix.py"}
{{< include ../examples/tasks_matrix.py >}}
```

This creates **4 tasks** (2 tasks × 2 models).

### models_matrix()

Generate model configurations with different generation settings:

``` {.python filename="models_matrix.py"}
{{< include ../examples/models_matrix.py >}}
```

This creates **16 tasks** (2 task × 2 models × 4 resoning_effort).

### configs_matrix()

Generate generation config combinations by specifying individual parameters:

``` {.python filename="configs_matrix.py"}
{{< include ../examples/configs_matrix.py >}}
```

This creates **16 tasks** (2 task × 2 models × 4 resoning_effort).

### solvers_matrix()

Generate solver configurations with different arguments:

``` {.python filename="solvers_matrix.py"}
{{< include ../examples/solvers_matrix.py >}}
```

This creates **3 tasks** (1 task × 3 solver configurations).

### agents_matrix()

Generate agent configurations with different arguments:

``` {.python filename="agents_matrix.py"}
{{< include ../examples/agents_matrix.py >}}
```

This creates **3 tasks** (1 task × 3 agent configurations).

## With Functions (Apply to All)

"With" functions apply the same setting to all items in a list, without creating a Cartesian product. Unlike matrix functions which multiply combinations, with functions keep the list size the same.

**Key difference:**

- **Matrix functions** create all combinations: `models_matrix(model=[A, B], temperature=[0.5, 1.0])` → 4 tasks (A at 0.5, A at 1.0, B at 0.5, B at 1.0)
- **With functions** apply to each item: `models_with(model=[A, B], temperature=0.5)` → 2 tasks (A at 0.5, B at 0.5)

### tasks_with()

Apply common settings to multiple tasks:

``` {.python filename="tasks_with.py"}
{{< include ../examples/tasks_with.py >}}
```

1. Apply the same model to both tasks
2. Apply the same generation config to both tasks

This creates **2 tasks** (2 tasks, each with the same model and config).

### models_with()

Apply common settings to multiple models:

``` {.python filename="models_with.py"}
{{< include ../examples/models_with.py >}}
```

1. Apply the same generation config to both models

This creates **2 tasks** (1 task × 2 models, each with the same config).

### configs_with()

Apply common settings to multiple configs:

``` {.python filename="configs_with.py"}
{{< include ../examples/configs_with.py >}}
```

1. Apply the same max_tokens to all three temperature configs

This creates **3 tasks** (1 task × 3 configs, each with the same max_tokens).

### solvers_with()

Apply common settings to multiple solvers:

``` {.python filename="solvers_with.py"}
{{< include ../examples/solvers_with.py >}}
```

This creates **3 tasks** (1 task × 3 solvers, each with the same max_attempts).

### agents_with()

Apply common settings to multiple agents:

``` {.python filename="agents_with.py"}
{{< include ../examples/agents_with.py >}}
```

This creates **3 tasks** (1 task × 3 agents, each with cache enabled).

### Combining Matrix and With

Mix parameter sweeps with common settings:

``` {.python filename="matrix_and_with.py"}
{{< include ../examples/matrix_and_with.py >}}
```

1. Create a matrix of 6 tasks (2 tasks × 3 temperature values)
2. Apply the same model to all 6 tasks from the matrix
3. Apply the same sandbox to all 6 tasks from the matrix

## Nested Sweeps

Matrix functions can be nested to create complex parameter grids. Use the unpacking operator `*` to expand inner matrix results:

**Example: Tasks with nested model sweep**

``` {.python filename="nested_model_sweep.py"}
{{< include ../examples/nested_model_sweep.py >}}
```

1. Total of 5 models: 1 single model + 4 from the matrix (2 models × 2 reasoning_effort values)
2. A single model configuration for Claude
3. Use the unpacking operator `*` to expand the nested model matrix into the list

This creates **10 tasks** (2 tasks × 5 model configurations).

**Example: Tasks with nested task sweep**

``` {.python filename="nested_task_sweep.py"}
{{< include ../examples/nested_task_sweep.py >}}
```

1. A single task configuration with specific arguments
2. Use the unpacking operator `*` to expand the nested task matrix into the list
3. Total of 4 tasks: 1 single task + 3 from the matrix (1 task × 3 language variants)

This creates **8 tasks** (4 task variants × 2 models).

::: callout-warning
### Watch Out for Combinatorial Explosion

Parameter sweeps grow multiplicatively. A sweep with:

- 3 tasks
- 4 models
- 5 temperature values
- 3 solver configurations

Results in 3 × 4 × 5 × 3 = **180 evaluations**.

Always use `--dry-run` to check the number of evaluations before running expensive grids.
:::

## Matrix Merge

When base objects already have values, matrix parameters are merged:

``` {.python}
tasks_matrix(
    task=FlowTask(
        name="task",
        config=GenerateConfig(temperature=0.5)  # <1>
    ),
    config=[
        GenerateConfig(max_tokens=1000),  # <2>
        GenerateConfig(max_tokens=2000),  # <2>
    ]
)
```

1. Base value of temperature=0.5
2. Adds max_tokens, keeps temperature=0.5

This creates 2 tasks: one with `temperature=0.5, max_tokens=1000` and another with `temperature=0.5, max_tokens=2000`.
