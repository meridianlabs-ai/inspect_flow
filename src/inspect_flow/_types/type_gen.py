import re
import subprocess
import tempfile
from pathlib import Path
from typing import Any, TypeAlias

from datamodel_code_generator import DataModelType, InputFileType, generate

from inspect_flow._types.flow_types import FlowConfig

# TODO:ransom private import
ADDITIONAL_IMPORTS = [
    "from inspect_ai.model import BatchConfig, GenerateConfig, ResponseSchema\n",
    "from inspect_ai.util import JSONSchema, SandboxEnvironmentSpec\n",
    "from inspect_ai.approval._policy import ApprovalPolicyConfig, ApproverPolicyConfig\n",
    "from inspect_flow._types.flow_types import FlowAgent, FlowEpochs, FlowOptions, FlowMatrix, FlowModel, FlowSolver, FlowTask\n",
]

Schema: TypeAlias = dict[str, Any]

ITEM_OR_LIST_FIELDS = {
    ("FlowConfig", "dependencies"),
    ("FlowConfig", "matrix"),
    ("FlowMatrix", "args"),
    ("FlowMatrix", "tasks"),
    ("FlowMatrix", "models"),
    ("FlowMatrix", "model_roles"),
    ("FlowMatrix", "solvers"),
    ("FlowTask", "args"),
    ("FlowTask", "model_roles"),
    ("FlowTask", "models"),
    ("FlowTask", "solvers"),
    ("FlowAgent", "args"),
    ("FlowSolver", "args"),
    ("FlowModel", "config"),
}


def add_item_option(field_schema: Schema) -> None:
    if "type" in field_schema:
        # Convert array typed value to anyOf
        assert field_schema["type"] == "array"
        array_type = {"type": "array", "items": field_schema["items"]}
        del field_schema["type"]
        del field_schema["items"]
        field_schema["anyOf"] = [array_type]

    # Find the array option
    any_of: list[Schema] = field_schema["anyOf"]
    array_field: Schema | None = None
    for field in any_of:
        if field["type"] == "array":
            array_field = field
            break
    assert array_field

    # Add an option for a single item in the array
    any_of.append(array_field["items"])


def transform_schema(schema: Schema) -> Schema:
    defs: Schema = schema["$defs"]
    classes: list[Schema] = [schema, *[v for v in defs.values()]]
    for c in classes:
        properties: Schema = c["properties"]
        for field_name, field_value in properties.items():
            if (c["title"], field_name) in ITEM_OR_LIST_FIELDS:
                add_item_option(field_value)

    return schema


def generate_typed_dict_code() -> list[str]:
    with tempfile.NamedTemporaryFile(mode="w+", suffix=".py") as tmp_file:
        generated_type_file = Path(tmp_file.name)

        # schema = transform_schema(FlowConfig.model_json_schema())
        schema = FlowConfig.model_json_schema()

        generate(
            str(schema),
            input_file_type=InputFileType.JsonSchema,
            output=generated_type_file,
            output_model_type=DataModelType.TypingTypedDict,
            custom_class_name_generator=lambda name: f"{name}Dict",
            use_generic_container_types=True,
        )

        with open(generated_type_file, "r") as f:
            lines = f.readlines()
    return lines


def modify_generated_code(lines: list[str]) -> list[str]:
    str_as_class = ["FlowTask", "FlowModel", "FlowSolver"]

    def replacement(m: re.Match[str]) -> str:
        if m.group(1) in str_as_class:
            return f"Union[str, {m.group(1)}, {m.group(0)}]"
        else:
            return f'Union[{m.group(1)}, "{m.group(0)}"]'

    generated_code: list[str] = [
        "# generated by type_gen.py (using datamodel-codegen)\n",
        "\n",
    ]
    section = "comment"
    for line in lines:
        if section == "comment":
            if line.strip().startswith("from"):
                section = "imports"
                generated_code.extend(ADDITIONAL_IMPORTS)
        elif section == "imports":
            generated_code.append(line)
            if line.strip().startswith("class"):
                section = "classes"
        elif section == "classes":
            if line.strip().startswith("class"):
                # Don't modify import or class definition lines
                generated_code.append(line)
            else:
                # Replace ClassNameDict with ClassName | ClassNameDict
                modified_line = re.sub(
                    r"\b(\w+)Dict\b",
                    replacement,
                    line,
                )
                generated_code.append(modified_line)
    return generated_code


def write_generated_code(generated_code: list[str]) -> None:
    output_file = Path(__file__).parent / "dicts.py"

    with open(output_file, "w") as f:
        f.writelines(generated_code)
    subprocess.run(["ruff", "check", "--fix", str(output_file)], check=True)
    subprocess.run(["ruff", "format", str(output_file)], check=True)


def main():
    lines = generate_typed_dict_code()
    generated_code = modify_generated_code(lines)
    write_generated_code(generated_code)


if __name__ == "__main__":
    main()
